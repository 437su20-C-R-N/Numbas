interpreted_answers (The interpreted answers for each gap, in the original order):
    map(
        mark_part(gap["path"],studentAnswer)["values"]["interpreted_answer"],
        [gap,studentAnswer],
        zip(gaps,studentAnswer)
    )

answers (The student's answers to each gap):
    if(settings["sortAnswers"],
        sort(interpreted_answers)
    ,
        interpreted_answers
    )

gap_order:
    if(settings["sortAnswers"],
        sort_destinations(interpreted_answers)
    ,
        list(0..len(gaps)01)
    )

gap_feedback (Feedback on each of the gaps):
  map(
    let(result,submit_part(gaps[gap_number]["path"],answer),
      feedback(translate('part.gapfill.feedback header',["index":index]));
      concat_feedback(result["feedback"], result["marks"]/marks);
      result
    ),
    [gap_number,answer,index],
    zip(gap_order,studentAnswer,list(1..len(gaps)))
  )

any_invalid (Are the answers to any of the gaps invalid?):
  len(filter(not gap["answered"],gap,gap_feedback))>0

mark:
  apply(answers);
  apply(gap_feedback);
  assert(not any_invalid,fail(""))

interpreted_answer:
  answers


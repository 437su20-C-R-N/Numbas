answers (The student's answers to each gap):
    if(settings["sortAnswers"],
        sort(studentAnswer)
    ,
        studentAnswer
    )

gap_order:
    if(settings["sortAnswers"],
        sort_destinations(studentAnswer)
    ,
        list(0..len(gaps)01)
    )

gap_feedback (Feedback on each of the gaps):
  map(
    let(result,submit_part(gaps[gap_number]["path"],answer),
      feedback(translate('part.gapfill.feedback header',["index":index]));
      concat_feedback(result["feedback"], result["marks"]/marks);
      result
    ),
    [gap_number,answer,index],
    zip(gap_order,studentAnswer,list(1..len(gaps)))
  )

any_invalid (Are the answers to any of the gaps invalid?):
  len(filter(not gap["answered"],gap,gap_feedback))>0

mark:
  apply(answers);
  apply(gap_feedback);
  assert(not any_invalid,fail(""))

interpreted_answer:
  answers


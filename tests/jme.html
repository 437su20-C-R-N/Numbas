<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
                    "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<link rel="stylesheet" href="qunit.css" type="text/css" media="screen" />
		<script src="qunit.js"></script>

		<!-- R.js - localisation -->
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/R/R.js"></script>
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/R/en-gb.js"></script>

		<!--JQuery scripts-->
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/jquery/jquery.js"></script>

		<!-- textile markup -->
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/textile/textile.js"></script>

		<!-- numbas stuff -->
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/numbas.js" charset="utf-8"></script>


		<script>
			$(document).ready(function(){


				//The vast majority of these tests are semi-useless "tiny case behaves as expected tests".
				//I'll add tests corresponding to real world errors as I encounter them

				Numbas.init = function() {

					var jme = Numbas.jme;
					var math = Numbas.math;
					var types = jme.types;
					var tokenise = jme.tokenise;

					function raisesNumbasError(fn,error,description) {
						raises(fn,function(e){return e.originalMessage == error},description);
					}

					module('Compiling');

					test('Booleans', function() {
						deepEqual(tokenise('true'),[new types.TBool(true)],'true');
						deepEqual(tokenise('TRUE'),[new types.TBool(true)],'TRUE');
						deepEqual(tokenise('True'),[new types.TBool(true)],'True');
						equal(tokenise('true')[0].value,true,'value is true');

						deepEqual(tokenise('false'),[new types.TBool(false)],'false');
						deepEqual(tokenise('FALSE'),[new types.TBool(false)],'FALSE');
						deepEqual(tokenise('False'),[new types.TBool(false)],'False');
						equal(tokenise('false')[0].value,false,'value is false');
					});
					test('Numbers', function() {
						deepEqual(tokenise('0'),[new types.TNum(0)],'0');
						deepEqual(tokenise('0.0'),[new types.TNum(0)],'0.0');

						raisesNumbasError(function(){ tokenise('.1')},'jme.tokenise.invalid','Invalid: .1');

						deepEqual(tokenise('1'),[new types.TNum(1)],'1');
						deepEqual(tokenise('1.0023'),[new types.TNum(1.0023)],'1.0023');

						deepEqual(tokenise('e'),[new types.TNum(Math.E)],'e');

						deepEqual(tokenise('pi'),[new types.TNum(Math.PI)],'pi');
						deepEqual(tokenise('PI'),[new types.TNum(Math.PI)],'PI');

						equal(tokenise('\\\\pi')[0].type,'name','compile "\\pi" returns a TName');

						deepEqual(tokenise('i'),[new types.TNum(math.complex(0,1))],'i');

						deepEqual(tokenise('infinity'),[new types.TNum(Infinity)],'infinity');
						deepEqual(tokenise('infty'),[new types.TNum(Infinity)],'infinity');
					});

					test('Names',function() {
						deepEqual(tokenise('x'),[new types.TName('x')],'x');
						deepEqual(tokenise('arg123'),[new types.TName('arg123')],'arg123');
						deepEqual(tokenise('a1b2'),[new types.TName('a1b2')],'a1b2');
						deepEqual(tokenise('X'),[new types.TName('X')],'X');
						deepEqual(tokenise('xyz'),[new types.TName('xyz')],'xyz');
						deepEqual(tokenise('$x'),[new types.TName('$x')],'$x');
						deepEqual(tokenise("f'''"),[new types.TName("f'''")],"f'''");
					});

					test('Operators', function() {
						deepEqual(tokenise('_'),[new types.TOp('_')],'_');
						deepEqual(tokenise('..'),[new types.TOp('..')],'..');
						deepEqual(tokenise('#'),[new types.TOp('#')],'#');
						deepEqual(tokenise('<='),[new types.TOp('<=')],'<=');
						deepEqual(tokenise('>='),[new types.TOp('>=')],'>=');
						deepEqual(tokenise('<>'),[new types.TOp('<>')],'<>');
						deepEqual(tokenise('&&'),[new types.TOp('and')],'^^');
						deepEqual(tokenise('||'),[new types.TOp('or')],'||');
						deepEqual(tokenise('|'),[new types.TOp('|')],'|');
						deepEqual(tokenise('*'),[new types.TOp('*')],'*');
						deepEqual(tokenise('+'),[new types.TOp('+u')],'+');
						deepEqual(tokenise('-'),[new types.TOp('-u')],'-');
						deepEqual(tokenise('/'),[new types.TOp('/')],'/');
						deepEqual(tokenise('^'),[new types.TOp('^')],'^');
						deepEqual(tokenise('<'),[new types.TOp('<')],'<');
						deepEqual(tokenise('>'),[new types.TOp('>')],'>');
						deepEqual(tokenise('='),[new types.TOp('=')],'=');
						deepEqual(tokenise('!'),[new types.TOp('not')],'!');
						deepEqual(tokenise('not'),[new types.TOp('not')],'not');
						deepEqual(tokenise('and'),[new types.TOp('and')],'and');
						deepEqual(tokenise('or'),[new types.TOp('or')],'or');
						deepEqual(tokenise('isa'),[new types.TOp('isa')],'isa');
						deepEqual(tokenise('except'),[new types.TOp('except')],'except');
					});

					test('Punctuation',function() {
						deepEqual(tokenise('('),[new types.TPunc('(')],'(');
						deepEqual(tokenise(')'),[new types.TPunc(')')],')');
						deepEqual(tokenise(','),[new types.TPunc(',')],',');
						deepEqual(tokenise('['),[new types.TPunc('[')],']');
						deepEqual(tokenise(']'),[new types.TPunc(']')],']');
					});

					test('String',function() {
						deepEqual(tokenise('"hi"'),[new types.TString('hi')],'"hi"');
						deepEqual(tokenise("'hi'"),[new types.TString('hi')],"'hi'");

						raisesNumbasError(function() {tokenise('"hi')},'jme.tokenise.invalid','Invalid: "hi');
						raisesNumbasError(function() {tokenise('hi"')},'jme.tokenise.invalid','Invalid: "hi');
					});

					test('Invalid expressions',function() {
						raisesNumbasError(function(){tokenise('x.1')},'jme.tokenise.invalid','Invalid: x.1');
					});

					var compile = function(s){ return jme.compile(s,jme.builtinScope) };

					test('jme.shunt',function() {
						raisesNumbasError(function(){ compile('x+') },'jme.shunt.not enough arguments','not enough arguments: x+')
						raisesNumbasError(function(){ compile('!') },'jme.shunt.not enough arguments','not enough arguments: !')
						raisesNumbasError(function(){ compile('f x,y')},'jme.shunt.no left bracket in function','no left bracket in function: f x,y');
						raisesNumbasError(function(){ compile('x]') },'jme.shunt.no left square bracket','no left square bracket: x]');
						raisesNumbasError(function(){ compile('x)') },'jme.shunt.no left bracket','no left bracket: x)');
						raisesNumbasError(function(){ compile('(x') },'jme.shunt.no right bracket','no right bracket: (x');
						raisesNumbasError(function(){ compile('[x,y') },'jme.shunt.no right square bracket','no right square bracket: [x,y');
						raisesNumbasError(function(){ compile('1 2 3') },'jme.shunt.missing operator','missing operator: 1 2 3');
					})


					test('jme.typecheck',function() {
						raisesNumbasError(function(){ compile('x()') },'jme.typecheck.function not defined','function not defined: x()');
						raisesNumbasError(function(){ jme.compile('x+y',new jme.Scope()) },'jme.typecheck.op not defined','op not defined with empty scope: x+y');
						raisesNumbasError(function(){ compile('gcd(2)') },'jme.typecheck.no right type definition','no right type definition: gcd(2)');
					});

				
					
					module('Evaluating');

					var evaluate = function(t,scope) { return jme.evaluate(t,scope) };

					test('Variables',function() {
						var scope = {variables: {
							x: new types.TNum(1),
							name: new types.TString('Bob')
						}};
						equals(evaluate('y',scope).type,'name','undefined variable remains a TName')
						equals(evaluate('x',scope).value,1,'substitute variable x=1')
						equals(evaluate('"hi {name}"',scope).value,'hi Bob','substitute into string');
					});

					test('Literals',function() {
						equals(evaluate('1').value,1,'1');
						equals(evaluate('true').value,true,'true');
						deepEqual(evaluate('1..3').value,[1,3,1,1,2,3],'1..3');
						deepEqual(evaluate('[1,2]').value.map(function(i){return i.value}),[1,2],'[1,2]');
						deepEqual(evaluate('[1,"hi",true]').value.map(function(i){return i.value}),[1,"hi",true],'[1,"hi",true]');
						equals(evaluate('"hi"').value,'hi','"hi"');
						equals(evaluate("'hi'").value,'hi',"'hi'");
						equals(evaluate('x').type,'name','x');
					});

					test('Operator precedence',function() {
						equals(evaluate('2*3!').value,12,'factorial highest: 2*3! = 2*(3!)');
						equals(evaluate('(2*3)!').value,6*5*4*3*2,'brackets work: (2*3)! = 6!');
						equals(evaluate('2^1^2').value,2,'exponentiation is right-associative: 2^1^2 = 2^(1^2)');
						equals(evaluate('2*3^2').value,18,'exponentation before multiplication: 2*3^2 = 2*(3^2)');
						equals(evaluate('5*4+3*2').value,26,'multiplication before addition: 5*4+3*2 = (5*4)+(3*2)');
						equals(evaluate('5/4+3/2').value,2.75,'division before addition: 5/4+3/2 = (5/4)+(3/2)');
						equals(evaluate('5*4/3-5/3*4').value,0,'multiplication and division equal precedence: 5*4/3 = 5/3*4');
						equals(evaluate('1/2/3').value,1/6,'division is left-associative: 1/2/3 = (1/2)/3');
						equals(evaluate('5-+2').value,3,'unary addition: 5-+2 = 5-2');
						equals(evaluate('5--2').value,7,'unary minus: 5--2 = 5+2');
						ok(evaluate('1+2*3|7^2'),'"divides" after arithmetic');
						equals(evaluate('1+2..5').value[0],3,'arithmetic before range .. operator: 1+2..5 = (1+2)..5');
						equals(evaluate('1..5#2').value[2],2,'range step operator');
						ok(evaluate('1..2 except 3'),'except operator');
						ok(evaluate('1+2<2+3'),'comparison operator lower than arithmetic: 1+2<2+3 = (1+2)<(2+3)');
						ok(evaluate('1<2=2<3'),'equality after inequality');
						ok(evaluate('1<2 && 3<4'),'AND after comparisons');
						equals(evaluate('true or false and false').value,true,'OR after AND');
						equals(evaluate('true xor true or true').value,false,'XOR after OR');
					});

					test('Synonyms',function() {
						equals(evaluate('5!=fact(5)').value,true,'x! == fact(x)');
						equals(evaluate('true and true = true & true = true && true').value,true,'true == & == &&');
						equals(evaluate('1|5 = divides(1,5)').value,true,'x|y == divides(x,y)');
						equals(evaluate('true||false = true or false').value,true,'x||y == x or y');
						equals(evaluate('sqr(2) = sqrt(2)').value,true,'sqr == sqrt');
						equals(evaluate('gcf(2,3) = gcd(2,3)').value,true,'gcf == gcd');
						equals(evaluate('sgn(4) = sign(4)').value,true,'sgn == sign');
						equals(evaluate('len(32) = abs(32) and length(32) = abs(32)').value,true,'len == length == abs');
						equals(jme.compile('verb(2)',jme.builtinScope,{notypecheck:true}).tok.name,'verbatim','verb == verbatim');
					});

					test('Arithmetic',function() {
						equals(evaluate('+2').value,2,'+2');
						equals(evaluate('-2').value,-2,'-2');
						equals(evaluate('1+2').value,3,'1+2');
						deepEqual(evaluate('i+1').value,math.complex(1,1),'i+1');
						deepEqual(evaluate('[1,2]+[3,4]').value.map(function(e){return e.value}),[1,2,3,4],'[1,2]+[3,4]');
						deepEqual(evaluate('[1,2]+3').value.map(function(e){return e.value}),[1,2,3],'[1,2]+3');
						deepEqual(evaluate('["x","y"]+"z"').value.map(function(e){return e.value}),['x','y','z'],'["x","y"]+"z"');
						equals(evaluate('"hi "+"there"').value,'hi there','"hi"+" there"');
						equals(evaluate('"n: "+1').value,'n: 1','"n: "+1');
						equals(evaluate('2+" things"').value,'2 things','2+" things"');
						deepEqual(evaluate('vector(1,2)+vector(2,3)').value,[3,5],'vector(1,2)+vector(2,3)');
						deepEqual(evaluate('matrix([1,0],[0,1])+matrix([0,1],[1,0])').value,[[1,1],[1,1]],'matrix([1,0],[0,1])+matrix([0,1],[1,0])');
						equals(evaluate('3-13').value,-10,'3-13');
						deepEqual(evaluate('vector(1,2)-vector(5,5)').value,[-4,-3],'vector(1,2)-vector(5,5)');
						deepEqual(evaluate('matrix([1,0],[0,1])-matrix([2,1],[2,1])').value,[[-1,-1],[-2,0]],'matrix([1,0],[0,1])-matrix([2,1],[2,1])');
						equals(evaluate('5*4').value,20,'5*4');
						equals(evaluate('i*i').value,-1,'i*i');
						deepEqual(evaluate('5*vector(1,2)').value,[5,10],'5*vector(1,2)');
						deepEqual(evaluate('vector(1,2)*5').value,[5,10],'vector(1,2)*5');
						deepEqual(evaluate('matrix([1,1],[3,2])*vector(1,2)').value,[3,7],'matrix([1,1],[3,2])*vector(1,2)');
						deepEqual(evaluate('5*matrix([1,0],[0,1])').value,[[5,0],[0,5]],'5*matrix([1,0],[0,1])');
						deepEqual(evaluate('matrix([1,0],[0,1])*5').value,[[5,0],[0,5]],'matrix([1,0],[0,1])*5');
						deepEqual(evaluate('matrix([1,2],[1,1])*matrix([2,3],[4,5])').value,[[10,13],[6,8]],'matrix([1,2],[1,1])*matrix([2,3],[4,5])');
						equals(evaluate('5/2').value,2.5,'5/2');
						deepEqual(evaluate('5/(1+i)').value,math.complex(2.5,-2.5),'5/(1+i)');
						deepEqual(evaluate('(1+i)/5').value,math.complex(0.2,0.2),'(1+i)/5');
						deepEqual(evaluate('(1+i)/(2-i)').value,math.complex(0.2,0.6),'(1+i)/(2+i)');
						equals(evaluate('2^4').value,16,'2^4');
						deepEqual(evaluate('(1+i)^5').value,math.complex(-4,-4),'(1+i)^5');
						deepEqual(evaluate('2^i').value,math.complex(0.7692389013639721,0.6389612763136348),'2^i');
					});

					test('Vector and Matrix operations',function() {
						equals(evaluate('dot(vector(1,2),vector(2,3))').value,8,'dot(vector(1,2),vector(2,3))');
						equals(evaluate('dot(matrix([1],[2],[3]),vector(6,5,4))').value,28,'dot(matrix([1],[2],[3]),vector(6,5,4))');
						equals(evaluate('dot(vector(6,5,4),matrix([1],[2],[3]))').value,28,'dot(vector(6,5,4),matrix([1],[2],[3]))');
						equals(evaluate('dot(matrix([1],[2],[3]),matrix([1],[2],[3]))').value,14,'dot(matrix([1],[2],[3]),matrix([1],[2],[3]))');
						deepEqual(evaluate('cross(vector(1,2,3),vector(5,6,7))').value,[-4,8,-4],'cross(vector(1,2,3),vector(5,6,7))');
						equals(evaluate('').value,0,'');
						equals(evaluate('').value,0,'');
						equals(evaluate('').value,0,'');
						equals(evaluate('').value,0,'');
					});
					
					module('Scopes');

					test('Variables',function() {
						deepEqual(jme.builtinScope.variables,{},'builtin scope has no variables');
						deepEqual(new jme.Scope().variables,{},'scope from constructor has no variables');
						var scope = new jme.Scope({
							variables: {
								x: new types.TNum(1),
								y: new types.TString('hi')
							}
						});
						ok(scope.variables.x,'add variables in scope constructor')
						var scope2 = new jme.Scope(scope,{variables: {x: new types.TNum(2)}});
						equals(scope2.variables.x.value,2,'override variable in old scope with new value');
						equals(scope2.variables.y.value,'hi','but other variables retained if not defined in later scope');
					});

					test('Functions',function() {
						ok(jme.builtinScope.functions['+'],'builtin scope has functions in it.');
						deepEqual(new jme.Scope().functions,{},'scope from constructor has no functions');
						var scope = new jme.Scope(jme.builtinScope,{
							functions: {
								'+':[(new jme.funcObj('+',[types.TBool,types.TBool],types.TBool,null,{nobuiltin:true}))]
							}
						});
						equals(scope.functions['+'].length,jme.builtinScope.functions['+'].length+1,'add overloaded function to old scope');
						equals(new Numbas.jme.Scope(scope,jme.builtinScope).functions['+'].length,scope.functions['+'].length,"don't duplicate functions when extending scope");
					});

					test('Rulesets',function() {
						deepEqual(new jme.Scope().rulesets,{},'scope from constructor has no rulesets');
						var scope = new jme.Scope({rulesets: jme.display.simplificationRules});
						ok(scope.rulesets.basic,'extend scope with some rulesets');
					});

				};


				Numbas.scriptPrefix = '../runtime/scripts/';
				Numbas.loadScript('../runtime/scripts/jme-display.js');
				Numbas.loadScript('../runtime/scripts/jme.js');
				Numbas.startOK = true;
				Numbas.tryInit();
			});
		</script>
	</head>
	<body>
		<h1 id="qunit-header">Numbas JME unit tests</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">test markup, will be hidden</div>
	</body>
</html>
